---
layout: post
title: "容器安全掃描與漏洞管理"
date: 2019-02-11 11:00:00 +0800
categories: [DevOps, Security]
tags: [Security, Docker, Vulnerability, Clair, Trivy, Container Security]
---

上週建立了 GitLab CI/CD Pipeline（參考 [GitLab CI/CD Pipeline 自動化部署](/posts/2019/02/04/gitlab-cicd-pipeline-automation/)），實現了自動化部署。但有個問題被忽略了：**安全性**。

上個月看到新聞，某公司因為使用有漏洞的 Docker image 被攻擊。檢查了一下我們的映像檔，發現用的 base image 有好幾個高風險 CVE（Common Vulnerabilities and Exposures）。

這週來整合容器安全掃描，確保不會部署有漏洞的映像檔。

## 容器安全的重要性

容器的漏洞來源：

1. **Base Image**：`openjdk:8` 可能包含舊版 OS 和函式庫
2. **應用程式依賴**：`log4j 2.14.0` 可能有漏洞（Log4Shell！）
3. **自己寫的程式碼**：SQL injection、XSS 等
4. **設定錯誤**：以 root 執行、暴露不必要的 port

一個常見的誤解：「容器是隔離的，應該很安全吧？」

**錯！**容器只是 process 隔離，不是完全隔離。如果容器內的應用程式有漏洞，攻擊者可能：
- 逃逸到 host
- 橫向移動到其他容器
- 竊取敏感資料

## 容器安全掃描工具

### Clair

- RedHat 開發的開源工具
- 掃描 Docker image 的已知漏洞
- Harbor 預設整合

### Trivy

- Aqua Security 開發的開源工具
- 支援多種格式（Docker、OCI、tar）
- 掃描速度快
- 易於整合到 CI/CD

### Anchore

- 企業級容器安全平台
- 功能強大但較複雜

這週使用 **Trivy**，因為它輕量、快速、易用。

## 安裝和使用 Trivy

### 本機安裝

```bash
# macOS
brew install aquasecurity/trivy/trivy

# Linux
wget https://github.com/aquasecurity/trivy/releases/download/v0.1.6/trivy_0.1.6_Linux-64bit.tar.gz
tar zxvf trivy_0.1.6_Linux-64bit.tar.gz
sudo mv trivy /usr/local/bin/
```

### 掃描 Docker Image

```bash
trivy image nginx:1.15

# 2019-02-11T11:00:00.000+0800  INFO    Detecting Debian vulnerabilities...
# 
# nginx:1.15 (debian 9.6)
# =======================
# Total: 215 (UNKNOWN: 0, LOW: 134, MEDIUM: 64, HIGH: 16, CRITICAL: 1)
```

會列出所有漏洞：
```
+--------------+------------------+----------+-------------------+
| LIBRARY      | VULNERABILITY ID | SEVERITY | INSTALLED VERSION |
+--------------+------------------+----------+-------------------+
| libc6        | CVE-2018-6485    | CRITICAL | 2.24-11+deb9u3    |
| openssl      | CVE-2018-0734    | HIGH     | 1.1.0j-1          |
| ...          | ...              | ...      | ...               |
+--------------+------------------+----------+-------------------+
```

### 只顯示高風險漏洞

```bash
trivy image --severity HIGH,CRITICAL nginx:1.15
```

### 掃描本機建置的映像檔

```bash
# 先建置
docker build -t my-shop-api:1.0.0 .

# 掃描
trivy image my-shop-api:1.0.0
```

結果：
```
my-shop-api:1.0.0 (debian 9.6)
==============================
Total: 342 (UNKNOWN: 0, LOW: 198, MEDIUM: 102, HIGH: 38, CRITICAL: 4)
```

天啊！38 個 HIGH、4 個 CRITICAL 漏洞！

## 修復容器漏洞

### 更新 Base Image

我們原本的 Dockerfile：
```dockerfile
FROM openjdk:8-jre

COPY target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

`openjdk:8-jre` 是基於很舊的 Debian，有很多漏洞。

改用 Alpine 版本（更小、更新）：
```dockerfile
FROM openjdk:8-jre-alpine

COPY target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

重新掃描：
```bash
docker build -t my-shop-api:1.0.1 .
trivy image --severity HIGH,CRITICAL my-shop-api:1.0.1

# Total: 0 (HIGH: 0, CRITICAL: 0)
```

太好了！沒有高風險漏洞了。

但還有 MEDIUM、LOW 漏洞，繼續優化。

### 使用更精確的版本

不要用 `latest` 或大版本號：

不好：
```dockerfile
FROM openjdk:8
FROM nginx:latest
```

好：
```dockerfile
FROM openjdk:8u191-jre-alpine3.9
FROM nginx:1.15.8-alpine
```

這樣可以：
- 固定版本，避免意外更新
- 選擇已知安全的版本

### 多階段建置

分離建置環境和執行環境：

```dockerfile
# 建置階段
FROM maven:3.5.4-jdk-8-alpine AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests

# 執行階段
FROM openjdk:8u191-jre-alpine3.9
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar

# 安全設定
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

好處：
- 最終映像檔只包含 JRE 和 JAR，不包含 Maven 和原始碼
- 映像檔大小從 600MB 降到 120MB
- 攻擊面更小

### 不要用 root 執行

預設容器內是 root，很危險！

加入非 root 使用者：
```dockerfile
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
```

驗證：
```bash
docker run my-shop-api:1.0.1 whoami
# appuser
```

## 整合到 CI/CD Pipeline

### 在 GitLab CI 中加入掃描

修改 `.gitlab-ci.yml`：

```yaml
stages:
  - build
  - test
  - security
  - package
  - deploy

# ... 其他 stages ...

# 安全掃描 stage
trivy-scan:
  stage: security
  image:
    name: aquasec/trivy:0.1.6
    entrypoint: [""]
  script:
    # 掃描映像檔
    - trivy image --exit-code 0 --severity LOW,MEDIUM --no-progress $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA
    - trivy image --exit-code 1 --severity HIGH,CRITICAL --no-progress $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA
  allow_failure: false
  only:
    - branches
```

`--exit-code 1` 表示如果發現 HIGH/CRITICAL 漏洞，pipeline 會失敗。

### 產生掃描報告

保存掃描結果：

```yaml
trivy-scan:
  stage: security
  image:
    name: aquasec/trivy:0.1.6
    entrypoint: [""]
  script:
    - trivy image --format json --output trivy-report.json $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA
    - trivy image --exit-code 1 --severity HIGH,CRITICAL --no-progress $DOCKER_REGISTRY/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA
  artifacts:
    reports:
      container_scanning: trivy-report.json
    paths:
      - trivy-report.json
    expire_in: 30 days
```

GitLab 會自動解析報告，在 Merge Request 中顯示漏洞。

### 每日定期掃描

即使不 commit，也要定期掃描（因為新的 CVE 會不斷發現）。

`.gitlab-ci.yml`：
```yaml
scheduled-scan:
  stage: security
  image:
    name: aquasec/trivy:0.1.6
    entrypoint: [""]
  script:
    - trivy image --severity HIGH,CRITICAL $DOCKER_REGISTRY/$IMAGE_NAME:latest
  only:
    - schedules
```

在 GitLab 設定 Pipeline Schedule：
1. 專案 →「CI/CD」→「Schedules」
2. 點「New schedule」
3. Description: `Daily security scan`
4. Interval Pattern: `0 2 * * *`（每天凌晨 2 點）
5. Target branch: `master`

## 掃描應用程式依賴

Trivy 也能掃描應用程式的依賴（不只是 OS package）。

### 掃描 Maven 專案

```bash
trivy fs --security-checks vuln --severity HIGH,CRITICAL .
```

Trivy 會分析 `pom.xml`，檢查 Java 依賴的漏洞。

結果：
```
pom.xml (maven)
===============
Total: 3 (HIGH: 2, CRITICAL: 1)

+------------------+------------------+----------+-------------------+
| LIBRARY          | VULNERABILITY ID | SEVERITY | INSTALLED VERSION |
+------------------+------------------+----------+-------------------+
| spring-core      | CVE-2018-1258    | HIGH     | 5.0.5.RELEASE     |
| jackson-databind | CVE-2018-7489    | CRITICAL | 2.9.4             |
+------------------+------------------+----------+-------------------+
```

### 修復方式

更新有漏洞的依賴：

`pom.xml`：
```xml
<properties>
    <spring.version>5.0.10.RELEASE</spring.version>
    <jackson.version>2.9.8</jackson.version>
</properties>
```

重新掃描：
```bash
mvn clean package
trivy fs .
# Total: 0 (HIGH: 0, CRITICAL: 0)
```

## 其他安全最佳實踐

### 1. 掃描密鑰洩漏

使用 gitleaks 檢查 Git history 中的密鑰：

```yaml
gitleaks-scan:
  stage: security
  image: zricethezav/gitleaks:latest
  script:
    - gitleaks --verbose --path=. --report=gitleaks-report.json
  artifacts:
    paths:
      - gitleaks-report.json
  allow_failure: true
```

### 2. 靜態程式碼分析

使用 SonarQube 檢查程式碼品質和安全問題：

```yaml
sonarqube-scan:
  stage: security
  image: maven:3.5.4-jdk-8
  script:
    - mvn sonar:sonar 
      -Dsonar.host.url=$SONAR_URL 
      -Dsonar.login=$SONAR_TOKEN
```

### 3. 限制容器權限

在 Kubernetes Deployment 中：

```yaml
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
      containers:
      - name: my-app
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
              - ALL
```

### 4. 使用 Network Policy

限制 Pod 之間的網路通訊：

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: my-shop-api-policy
spec:
  podSelector:
    matchLabels:
      app: my-shop-api
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: nginx-ingress
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: mysql
    ports:
    - protocol: TCP
      port: 3306
```

### 5. 定期更新依賴

使用 Dependabot（GitHub）或 Renovate（GitLab）自動建立 PR 更新依賴。

## Harbor 的安全掃描

如果使用 Harbor 作為 Registry（我們之前有介紹），它內建 Trivy 掃描。

### 啟用自動掃描

1. 登入 Harbor
2. 「Administration」→「Interrogation Services」
3. 選「Trivy」
4. 點「Edit」
5. 勾選「Scan on push」

現在每次 push 映像檔都會自動掃描。

### 設定部署策略

「Projects」→ 選擇專案 →「Configuration」
- 勾選「Prevent vulnerable images from running」
- Severity: `Critical`

這樣 K8s 會拒絕部署有 Critical 漏洞的映像檔。

## 監控和告警

### 設定 Slack 通知

當發現高風險漏洞時通知團隊：

```yaml
notify-vulnerability:
  stage: security
  script:
    - |
      VULN_COUNT=$(trivy image --severity CRITICAL --format json $IMAGE | jq '[.Results[].Vulnerabilities // []] | add | length')
      if [ "$VULN_COUNT" -gt "0" ]; then
        curl -X POST $SLACK_WEBHOOK_URL \
          -H 'Content-Type: application/json' \
          -d "{\"text\":\"⚠️ 發現 $VULN_COUNT 個 CRITICAL 漏洞：$IMAGE\"}"
      fi
  when: always
```

### 建立安全儀表板

在 Grafana 中建立儀表板，追蹤：
- 映像檔漏洞數量趨勢
- 各嚴重程度的漏洞分佈
- 未修復漏洞的老化時間

## 遇到的問題

### 問題一：Trivy 下載漏洞資料庫很慢

Trivy 第一次執行會下載漏洞資料庫（約 200MB）。

解決方法：使用 cache

```yaml
trivy-scan:
  cache:
    paths:
      - .trivycache/
  script:
    - trivy image --cache-dir .trivycache/ $IMAGE
```

或使用 Trivy server mode（多個 runner 共用）。

### 問題二：太多 LOW 和 MEDIUM 漏洞

有些漏洞修復成本高，但風險低。

解決方法：
1. 設定 allowlist 忽略特定 CVE
2. 只在 HIGH/CRITICAL 時失敗
3. 定期 review MEDIUM 漏洞

建立 `.trivyignore`：
```
# 這個 CVE 影響不大，暫時忽略
CVE-2019-12345

# 等待 upstream 修復
CVE-2019-67890
```

### 問題三：掃描太久，拖慢 Pipeline

Trivy 掃描大映像檔需要時間。

解決方法：
1. 使用較小的 base image（alpine）
2. 使用 multi-stage build 減少層級
3. 平行執行掃描和其他 job

```yaml
trivy-scan:
  stage: security
  needs: ["build-docker"]  # 不等整個 test stage
```

## 實際效果

整合安全掃描後：

**Before：**
- 不知道映像檔有什麼漏洞
- 部署後才發現安全問題
- 修復成本高（已經在生產環境了）

**After：**
- 每次 commit 自動掃描
- 高風險漏洞會阻擋 pipeline
- MR 中就能看到漏洞，merge 前修復
- 定期掃描提醒更新依賴

上週掃描發現我們用的 `spring-boot-starter-web` 有 CVE，升級到新版本就解決了。如果沒有掃描，這個漏洞可能會一直存在到生產環境。

## 心得

以前覺得安全掃描是「有空再做」的事，現在發現其實不難，而且很重要。

Trivy 真的很好用，安裝簡單、執行快速、整合容易。加到 CI/CD Pipeline 只要幾行設定，但能大幅提升安全性。

而且掃描報告很詳細，會告訴你：
- 哪個套件有漏洞
- 漏洞的嚴重程度
- CVE 編號（可以查詳細資訊）
- 有沒有修復版本

這讓修復變得很明確，不用自己去研究。

下週要研究 Infrastructure as Code（IaC），使用 Terraform 管理雲端資源。目前我們的 K8s 叢集都是手動建立的，想要能用程式碼管理，方便重現和災難恢復。
