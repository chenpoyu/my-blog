---
layout: post 
title: "實踐 SOLID 原則：將遺留代碼解耦合的實戰紀錄"
date: 2016-05-11 09:00:00 +0800 
categories: [設計模式, Java] 
tags: [SOLID原則, 重構, 解耦合]
---

在職場上，我們很少有機會從零開始寫新專案。更多時候，我們是在維護前輩留下來的「經驗」。最近我負責重構一個舊有的報表匯出系統，這是一個實踐 **SOLID 原則** 的絕佳案例。

## 原始狀況：萬能類別 (God Class)

最初的 `ReportManager` 類別大約有 2000 行，它負責了：

1. 從資料庫讀取數據。
2. 根據複雜的業務邏輯過濾數據。
3. 將數據格式化成 CSV 或 Excel。
4. 將檔案上傳到 FTP 伺服器並發送 Email 通知。

這違反了 **單一職責原則 (SRP)**。只要 FTP 密碼改了，或是報表要多加一欄，你都得動這個類別，風險極高。

## 重構第一步：拆解職責 (SRP & ISP)

我首先將功能拆分，這符合 **介面隔離原則 (ISP)**，用戶端不應該強迫依賴它們不使用的方法。

* `DataReader`：負責資料撈取。
* `ReportFormatter`：負責格式轉換。
* `NotificationService`：負責通知。

## 重構第二步：依賴倒置原則 (DIP)

在舊程式碼中，`ReportManager` 直接在內部 `new` 出了 `SmtpNotification` 物件。這導致如果要改用 `SmsNotification`，就必須修改主邏輯。

**錯誤示範：**

```java
public class ReportManager {
    private SmtpNotification notifier = new SmtpNotification(); // 強耦合
}

```

**修正後：**
應該依賴於「抽象」而非「實作」。

```java
public interface NotificationService {
    void notify(String message);
}

public class ReportManager {
    private final NotificationService notificationService;

    // 透過建構子注入 (Dependency Injection)
    public ReportManager(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}

```

## 重構第三步：開閉原則 (OCP) 的終極實踐

假設現在客戶要求報表除了 CSV，還要支援 PDF 和 JSON。如果我們用 `switch-case` 來判斷格式，就又回到了老路。

所以要結合 **策略模式 (Strategy)** 與 **工廠模式 (Factory)**：

### 1. 抽象化格式器

```java
public interface ReportFormatter {
    byte[] format(List<Data> data);
    boolean isSupport(String formatType);
}

```

### 2. 各自的實作類別

```java
public class PdfFormatter implements ReportFormatter {
    public boolean isSupport(String type) { return "PDF".equalsIgnoreCase(type); }
    public byte[] format(List<Data> data) { /* PDF 產生邏輯 */ return new byte[0]; }
}

public class CsvFormatter implements ReportFormatter {
    public boolean isSupport(String type) { return "CSV".equalsIgnoreCase(type); }
    public byte[] format(List<Data> data) { /* CSV 產生邏輯 */ return new byte[0]; }
}

```

### 3. 動態加載 (Registry Pattern)

在 Spring 框架中，可以輕易地注入一個 `List<ReportFormatter>`，並根據類型動態選擇。

```java
@Service
public class ReportService {
    @Autowired
    private List<ReportFormatter> formatters;

    public byte[] generateReport(List<Data> data, String type) {
        return formatters.stream()
            .filter(f -> f.isSupport(type))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("不支援的格式"))
            .format(data);
    }
}

```

## 成果與省思

經過這次重構，成功達到了以下目標：

* **里氏替換原則 (LSP)**：任何 `ReportFormatter` 的子類都可以替換掉父類而不影響行為。
* **維護性提升**：新增格式時，只需新增一個 Class，現有的 `ReportService` 程式碼一行都不必改（嚴格遵守 OCP）。
* **測試容易**：我們可以輕鬆地 Mock `NotificationService` 來測試報表產生的邏輯。

## 結語

SOLID 原則不是教條，而是為了應對「變動」。當整個的系統開始讓人感到「改不動」時，就是回頭審視這些原則的最佳時機。
